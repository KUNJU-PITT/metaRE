<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Pavel Cherenkov" />

<meta name="date" content="2017-08-02" />

<title>Quick Start for metaRE</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Quick Start for metaRE</h1>
<h4 class="author"><em>Pavel Cherenkov</em></h4>
<h4 class="date"><em>2017-08-02</em></h4>



<div id="overview" class="section level1">
<h1>Overview</h1>
<p>metaRE is an R package for finding cis-regulatory elements associated with significant changes in gene expression in response to a stimulus (hormones, stress etc.). It uses meta-analysis of multiple expression profiling studies and a set of gene promoters to analyze, which cis-regulatory elements are associated with gene regulation via a stimulus.</p>
<p>Analysis is run in five steps: - DEG (differientially expressed genes) identification - Cis-regulatory element search - Calculation of association between cis-regulatory element presence and changes in gene expression - Meta-analysis - Permuation test</p>
<p>In order to walk you through the whole analysis, we will search for hexamers that are associated with primary auxin response in <em>Arabidopsis thaliana</em>.</p>
<div id="deg-identification" class="section level2">
<h2>DEG identification</h2>
<p>First you need to collect expression profiling studies that test the same hypothesis and then identify DEGs in each of the studies. This package provides tools to simplify acquisition of studies for NCBI GEO database using <em>GEOquery</em> package and DEG identification using <em>limma</em> and <em>edgeR</em> packages.</p>
<p>There is an example collection of dataset metadata included in package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(metaRE)
MA_AT_auxin</code></pre></div>
<p>The above list contains the following data for each dataset: - <strong>treatment</strong> - GEO IDs of samples treated with auxin - <strong>control</strong> - GEO IDs of control samples - <strong>name</strong> - dataset name for further use - <strong>log2</strong> - flag that indicates whether the dataset is stored in logarithmic scale</p>
<p>First, the data has to be downloaded and converted to logarithmic scale using <em>prepareGEO</em> and prepared for processing by <em>preprocessGeneExpressionData</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">experiments &lt;-<span class="st"> </span><span class="kw">list</span>()

for (ma in MA_AT_auxin) {
    <span class="co"># Download the data from GEO, convert to log2 if necessary.</span>
    exprs &lt;-<span class="st"> </span><span class="kw">prepareGEO</span>(<span class="dt">control=</span>ma$control, <span class="dt">treatment=</span>ma$treatment,
                         <span class="dt">isLog2=</span>ma$log2)

    <span class="co"># Store in experiments for further processing</span>
    <span class="co"># Here 'type' can be either 'MA' or 'RNA', which tells if dataset is</span>
    <span class="co"># microarray expression levels or RNA-Seq RNA counts.</span>
    experiments[[ma$name]] &lt;-<span class="st"> </span><span class="kw">list</span>(
        <span class="dt">control=</span>ma$control, <span class="dt">treatment=</span>ma$treatment, <span class="dt">type=</span><span class="st">&quot;MA&quot;</span>, <span class="dt">data=</span>exprs
    )
}</code></pre></div>
<p>You can use <em>preprocessGeneExpressionData</em> to find DEGs in many datasets at once.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># We will analyze up- and down-regulation separately. We will define 2 </span>
<span class="co"># functions that will select up- and down- regulated genes in 'classes' varaible.</span>
logFCThreshold &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="fl">1.5</span>)
pValThreshold &lt;-<span class="st"> </span><span class="fl">0.05</span>
classes &lt;-<span class="st"> </span><span class="kw">list</span>(
    <span class="dt">up=</span>function(df) df$logFC &gt;<span class="st"> </span>logFCThreshold &amp;<span class="st"> </span>df$adj.P.Val &lt;<span class="st"> </span>pValThreshold,
    <span class="dt">down=</span>function(df) df$logFC &lt;<span class="st"> </span>-logFCThreshold &amp;<span class="st"> </span>df$adj.P.Val &lt;<span class="st"> </span>pValThreshold
)

<span class="co"># This will create a list of GeneClassificationMatix objects, one matrix per DEG </span>
<span class="co"># class. GeneClassificationMatix is a logical matrix, where each row corresponds</span>
<span class="co"># to a gene, each column corresponds to a dataset, and values tell if a gene </span>
<span class="co"># belongs to this DEG class in this dataset.</span>
<span class="co"># The last parameter is mulitple testing correction method as accepted by p.adjust</span>
degs &lt;-<span class="st"> </span><span class="kw">preprocessGeneExpressionData</span>(experiments, classes, <span class="st">'fdr'</span>)
<span class="kw">head</span>(degs$up)
<span class="kw">head</span>(degs$down)</code></pre></div>
<p>You can also process a single dataset with <em>processMicroarray</em> or <em>processRNACounts</em>. The result will be a data.frame, where rows correspond to genes, columns correspond to DEG class, values tell if a gene belongs to a DEG class.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ma &lt;-<span class="st"> </span>experiments[[<span class="dv">1</span>]]
<span class="co"># The syntax is exactly the same for processRNACounts</span>
singleExperiment &lt;-<span class="st"> </span><span class="kw">processMicroarray</span>(ma$data, ma$treatment, ma$control, classes, <span class="st">'fdr'</span>)

<span class="kw">head</span>(singleExperiment)</code></pre></div>
<p>You may choose to perform the DEG identification yourself with different set of tools, or get dataset from othefr databases. In this case for further analysis you will need to create a GeneClassificationMatrix yourself.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Let 'up', 'down' be your custom DEG matrix</span>
genes &lt;-<span class="st"> </span><span class="dv">1000</span>
exps &lt;-<span class="st"> </span><span class="dv">6</span>
total &lt;-<span class="st"> </span>genes*exps

up &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(total) &lt;<span class="st"> </span><span class="fl">0.05</span>, genes, exps)
down &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(total) &lt;<span class="st"> </span><span class="fl">0.05</span>, genes, exps)
custom_degs &lt;-<span class="st"> </span><span class="kw">list</span>(
    <span class="dt">up=</span><span class="kw">GeneClassificationMatrix</span>(up),
    <span class="dt">down=</span><span class="kw">GeneClassificationMatrix</span>(down)
)</code></pre></div>
</div>
<div id="cis-regulatory-element-search" class="section level2">
<h2>Cis-regulatory element search</h2>
<p>For cis-regulatory element search we will need a character vector of promoters (or other regulatory regions) with names that correspond to the same gene names that we used in DEG identification.</p>
<p>If you have a fasta file with the needed sequences, I would recommend to use <em>Biostrings</em> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">promoters &lt;-<span class="st"> </span>Biostrings::<span class="kw">readDNAStringSet</span>(<span class="st">'/path/to/file.fasta'</span>)
promoters &lt;-<span class="st"> </span><span class="kw">setNames</span>(<span class="kw">as.character</span>(promoters), <span class="kw">names</span>(promoters))</code></pre></div>
<p>In our example though we are going to use <em>biomaRt</em> package to download the sequences:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(biomaRt)
<span class="co"># Connect to Arabidopsis thaliana mart.</span>
mart &lt;-<span class="st"> </span><span class="kw">useMart</span>(<span class="st">'plants_mart'</span>, <span class="dt">host=</span><span class="st">&quot;plants.ensembl.org&quot;</span>, <span class="dt">dataset=</span><span class="st">'athaliana_eg_gene'</span>)
<span class="co"># Get gene promoters by ATH1 identifiers from our DEG matrix.</span>
promoters &lt;-<span class="st"> </span><span class="kw">getBM</span>(
    <span class="dt">attributes=</span><span class="kw">c</span>(<span class="st">&quot;affy_ath1_121501&quot;</span>, <span class="st">&quot;gene_flank&quot;</span>),
    <span class="dt">filters=</span><span class="kw">c</span>(<span class="st">&quot;affy_ath1_121501&quot;</span>,<span class="st">&quot;upstream_flank&quot;</span>),
    <span class="dt">values=</span><span class="kw">list</span>(<span class="kw">rownames</span>(degs$up), <span class="dv">1500</span>),
    <span class="dt">mart=</span>mart,
    <span class="dt">checkFilters=</span><span class="ot">FALSE</span>,
    <span class="dt">bmHeader=</span><span class="ot">TRUE</span>
)
<span class="co"># Convert data.frame to named character vector</span>
promoters &lt;-<span class="st"> </span><span class="kw">setNames</span>(promoters$<span class="st">`</span><span class="dt">Flank (Gene)</span><span class="st">`</span>, promoters$<span class="st">`</span><span class="dt">AFFY ATH1 121501 probe</span><span class="st">`</span>)</code></pre></div>
<p>Now we will enumerate all possible hexamers in these promoters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># This function finds all possible oligomers of the fixed length in the promoter</span>
<span class="co"># vector and returns a GeneClassificationSparse object.</span>
<span class="co"># By default rc=TRUE which means that oligomers are considered equal to their </span>
<span class="co"># reverse complements (e.g. AACCGG == CCGGTT)</span>
regElements &lt;-<span class="st"> </span><span class="kw">enumerateOligomers</span>(promoters, <span class="dv">6</span>)

<span class="co"># The result is a named list of integer vectors. Names are cis-regulatory </span>
<span class="co"># elements, vectors are indices of genes in which this elements are present.</span>
<span class="co"># Gene names are stored in 'geneNames' attribute of the result, which can be</span>
<span class="co"># accessed by 'geneNames(x)' funciton.</span>
<span class="kw">head</span>(regElements)</code></pre></div>
<p>This package provides tools to search for: - Fixed length oligomers (<em>enumerateOligomers</em>) - Repeats (<em>enumerateRepeats</em>) - Spaced dyads with fixed core (<em>enumerateDyadsWithCore</em>) - Consensuses (<em>enumeratePatterns</em>)</p>
<p>If you wish you can provide your own data on presence of cis-regulatory elements (e.g. PWM or HMM). In order to use this data you will need to construct a <em>GeneClassificationSparse</em> object yourself.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data &lt;-<span class="st"> </span><span class="kw">list</span>(
    <span class="dt">elem1=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">10</span>),
    <span class="dt">elem2=</span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">9</span>),
    <span class="dt">elem3=</span><span class="dv">2</span>
)
genes &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;gene&quot;</span>, <span class="dv">1</span>:<span class="dv">10</span>)
regElements &lt;-<span class="st"> </span><span class="kw">GeneClassificationSparse</span>(data, genes)</code></pre></div>
</div>
<div id="regulation-element-association" class="section level2">
<h2>Regulation-element association</h2>
<p>Given <em>GeneClassificationMatrix</em> and <em>GeneClassificationSparse</em> object we can calculate p-values of association between element presence in promoter and changes in gene expression using <em>calculateMassContingencyTablePvalues</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pvalues &lt;-<span class="st"> </span><span class="kw">list</span>()

for (class in <span class="kw">names</span>(degs)) {
    <span class="co"># By default this looks for enrichment.</span>
    <span class="co"># Use &quot;alternative='less'&quot; for depletion or &quot;alternative='two.sided'&quot; for both.</span>
    pvalues[[class]] &lt;-<span class="st"> </span><span class="kw">calculateMassContingencyTablePvalues</span>(regElements, degs[[class]])
    
    <span class="co"># The result is a float matrix of p-values, where rows correspond to </span>
    <span class="co"># cis-regulatory elements, columns correspond to datasets, values are raw</span>
    <span class="co"># p-values.</span>
    <span class="kw">print</span>(class)
    <span class="kw">head</span>(pvalues[[class]])
}</code></pre></div>
<p>P-values are calculated using Fisher’s exact test.</p>
</div>
<div id="meta-analysis" class="section level2">
<h2>Meta-analysis</h2>
<p>In the previous step we obtained p-values of enrichment for each individual dataset, now we are going to perform the meta-analysis by combining the p-values using Fisher’s combined test.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">metaPvalues &lt;-<span class="st"> </span><span class="kw">list</span>()


for (class in <span class="kw">names</span>(pvalues)) {
    <span class="co"># 'adjust' is multiple testing correction method</span>
    <span class="co"># 'threshold' is a cutoff value for adjusted meta p-value</span>
    metaPvalues[[class]] &lt;-<span class="st"> </span><span class="kw">calcMetaAssociation</span>(
        pvalues[[class]], <span class="dt">adjust=</span><span class="st">'bonferroni'</span>, <span class="dt">threshold=</span><span class="fl">0.05</span>
    )
    
    <span class="co"># The result is a data.frame with Meta.P.Value and Adj.Meta.P.Value columns.</span>
    <span class="co"># All elements with Adj.Meta.P.Value above cutoff threshold are removed from </span>
    <span class="co"># results</span>
    <span class="kw">print</span>(class)
    <span class="kw">head</span>(metaPvalues[[class]])
}</code></pre></div>
<p>This and the previous step can be reduced with the following shortcut:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">metaPvalues &lt;-<span class="st"> </span><span class="kw">list</span>()

for (class in <span class="kw">names</span>(degs)) {
    <span class="co"># This performs both 'calculateMassContingencyTablePvalues' and</span>
    <span class="co"># 'calcMetaAssociation' in order.</span>
    metaPvalues[[class]] &lt;-<span class="st"> </span><span class="kw">testRegulationHypotheses</span>(
        regElements, degs[[class]], <span class="dt">adjust=</span><span class="st">'bonferroni'</span>, <span class="dt">threshold=</span><span class="fl">0.05</span>
    )
}</code></pre></div>
</div>
<div id="permuation-test" class="section level2">
<h2>Permuation test</h2>
<p>The previous step is performed in order to reduce the number of investigated elements for permuation testing. In each permutation genes are assigned a random promoter without replacement. Then meta p-value is calculated and compared to the original one. Permuation p-value is the rate of random meta p-values more extreme than the original one.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Enable doParallel backend for parallel processing of permutation test.</span>
<span class="kw">library</span>(doParallel)
<span class="kw">registerDoParallel</span>()

results &lt;-<span class="st"> </span><span class="kw">list</span>()
for (class in <span class="kw">names</span>(metaPvalues)) {
    <span class="co"># Analyze only elements that pass the meta p-value threshold.</span>
    sigRegElements &lt;-<span class="st"> </span><span class="kw">GeneClassificationSparse</span>(
        regElements[<span class="kw">rownames</span>(metaPvalues[[class]])],
        <span class="kw">geneNames</span>(regElements)
    )
    
    <span class="co"># Calculate the number of permutations required to obtain reasonable</span>
    <span class="co"># p-values to pass the Bonferroni adjusted cutoff threshold</span>
    threshold &lt;-<span class="st"> </span><span class="fl">0.05</span>
    n &lt;-<span class="st"> </span><span class="kw">integer</span>(<span class="kw">length</span>(sigRegElements)*<span class="dv">50</span>/threshold)
    
    <span class="co"># Permuation test every 'perRun' iterations stores the preliminary results</span>
    <span class="co"># in 'outfile' and removes elements that in future will not be able to</span>
    <span class="co"># pass the 'pvaluePreFilter' threshold.</span>
    outfile &lt;-<span class="st"> </span><span class="kw">tempfile</span>()
    results[[class]] &lt;-<span class="st"> </span>metaRE::<span class="kw">permutationTest</span>(
        sigRegElements, degs[[degClass]], n, <span class="dt">outfile=</span>outfile,
        <span class="dt">pvaluePreFilter=</span>threshold/<span class="kw">length</span>(sigRegElements), <span class="dt">perRun=</span><span class="dv">5000</span>
    )
    
    <span class="kw">print</span>(class)
    <span class="kw">head</span>(results[[class]])
    
    <span class="co"># After the permutation test you can select the elements that pass the</span>
    <span class="co"># threshold and consider them as significantly associated with stimulus</span>
    <span class="co"># response.</span>
    <span class="kw">print</span>(results[[class]]$Hypothesis[results[[class]]$Permutation.P.Value &lt;<span class="st"> </span>threshold/<span class="kw">length</span>(sigRegElements)])
}</code></pre></div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
